import java.util.Arrays;
import java.util.HashMap;
import java.util.LinkedList;

class Solution {
    private static LinkedList<Integer>[] graph;
    private static int[] incomingEdges;

    public static void main(String[] args) {
        int[][] edges = {
                {4, 11}, {1, 12}, {8, 3}, {12, 7}, {4, 2},
                {7, 11}, {4, 8}, {9, 6}, {10, 11}, {6, 10},
                {3, 5}, {11, 1}, {5, 3}, {11, 9}, {3, 8}
        };
        System.out.println(Arrays.toString(solution(edges)));

    }

    static int[] answer = new int[4];
    public static int[] solution(int[][] edges) {
        int len = 0;
        for (int[] edge : edges) { len = Math.max(len, edge[0]); }
        incomingEdges = new int[len + 1];
        graph = new LinkedList[len + 1];

        // 그래프 초기화
        initGraph(edges);

        // 임의의 정점 찾기
        int root = findCreateVertex();

        // 그래프의 사이즈 (이후에 2개의 그래프만 구해 전체에서 빼기 위해)
        int graphSize = graph[root].size();

        for(int i = 0; i < graph[root].size(); i++) {
            findGraph(graph[root].get(i));
        }

        answer[1] = graphSize - answer[3];
        return answer;
    }

    private static void initGraph(int[][] edges) {
        for(int i = 0; i<graph.length; i++) {
            graph[i] = new LinkedList<>();
        }

        for (int[] edge : edges) {
            graph[edge[0]].add(edge[1]);
            incomingEdges[edge[1]]++;
        }
    }

    // 임의의 정점은 나가는 간선이 2개 이상
    // 들어오는 간선은 없음
    private static int findCreateVertex() {
        for(int i = 1; i < graph.length; i++) {
            if(graph[i].size() >= 2 && incomingEdges[i] == 0) {
                return i;
            }
        }
        return 0;
    }

    // 8자, 1자 그래프 탐색
    // 전체 그래프에서 뺄 두 개의 그래프를 8자와 1자로 한 이유는, 도넛의 경우 나가는 간선과 들어오는 간선이 2개이거나 1개인
    // 경우 모두 성립하여 조건이 까다롭기 때문
    private static void findGraph(int idx) {
        int size = graph[idx].size();
        // 8자 그래프는 나가는 간선이 1개
        if(size == 2 && incomingEdges[idx] >= 2){
            System.out.println(idx + "8");
            answer[3]++;
        }
        // 막대 그래프는 나가는 간선이 없음
        else if(incomingEdges[idx] == 1){
            System.out.println(idx + " 막대");
            answer[2]++;
        }
    }

}mport java.util.Arrays;
import java.util.HashMap;
import java.util.LinkedList;

class Solution {
    private static LinkedList<Integer>[] graph;
    private static int[] incomingEdges;

    public static void main(String[] args) {
        int[][] edges = {
                {4, 11}, {1, 12}, {8, 3}, {12, 7}, {4, 2},
                {7, 11}, {4, 8}, {9, 6}, {10, 11}, {6, 10},
                {3, 5}, {11, 1}, {5, 3}, {11, 9}, {3, 8}
        };
        System.out.println(Arrays.toString(solution(edges)));

    }

    static int[] answer = new int[4];
    public static int[] solution(int[][] edges) {
        int len = 0;
        for (int[] edge : edges) { len = Math.max(len, edge[0]); }
        incomingEdges = new int[len + 1];
        graph = new LinkedList[len + 1];

        // 그래프 초기화
        initGraph(edges);

        // 임의의 정점 찾기
        int root = findCreateVertex();

        // 그래프의 사이즈 (이후에 2개의 그래프만 구해 전체에서 빼기 위해)
        int graphSize = graph[root].size();

        for(int i = 0; i < graph[root].size(); i++) {
            findGraph(graph[root].get(i));
        }

        answer[1] = graphSize - answer[3];
        return answer;
    }

    private static void initGraph(int[][] edges) {
        for(int i = 0; i<graph.length; i++) {
            graph[i] = new LinkedList<>();
        }

        for (int[] edge : edges) {
            graph[edge[0]].add(edge[1]);
            incomingEdges[edge[1]]++;
        }
    }

    // 임의의 정점은 나가는 간선이 2개 이상
    // 들어오는 간선은 없음
    private static int findCreateVertex() {
        for(int i = 1; i < graph.length; i++) {
            if(graph[i].size() >= 2 && incomingEdges[i] == 0) {
                return i;
            }
        }
        return 0;
    }

    // 8자, 1자 그래프 탐색
    // 전체 그래프에서 뺄 두 개의 그래프를 8자와 1자로 한 이유는, 도넛의 경우 나가는 간선과 들어오는 간선이 2개이거나 1개인
    // 경우 모두 성립하여 조건이 까다롭기 때문
    private static void findGraph(int idx) {
        int size = graph[idx].size();
        // 8자 그래프는 나가는 간선이 1개
        if(size == 2 && incomingEdges[idx] >= 2){
            System.out.println(idx + "8");
            answer[3]++;
        }
        // 막대 그래프는 나가는 간선이 없음
        else if(incomingEdges[idx] == 1){
            System.out.println(idx + " 막대");
            answer[2]++;
        }
    }

}
